//
// Created by janos on 20.11.19.
//

#pragma once

#include <Eigen/Core>

//0.816847572980459  0.091576213509771
//0.091576213509771  0.816847572980459
//0.091576213509771  0.091576213509771
//0.108103018168070  0.445948490915965
//0.445948490915965  0.108103018168070
//0.445948490915965  0.445948490915965
//
//
//0.109951743655322
//0.109951743655322
//0.109951743655322
//0.223381589678011
//0.223381589678011
//0.223381589678011
//
//0.0  0.0
//1.0  0.0
//0.0  1.0


template<class T>
class QuadratureRefTriangle
{
private:
    using Vector6R = Eigen::Matrix<T, 6, 1>;

    const Eigen::Matrix<T, 6, 2> interpolationPoints = (Eigen::Matrix<T, 6, 2>{}
         << T(0.816847572980459),  T(0.091576213509771),
            T(0.091576213509771),  T(0.816847572980459),
            T(0.091576213509771),  T(0.091576213509771),
            T(0.108103018168070),  T(0.445948490915965),
            T(0.445948490915965),  T(0.108103018168070),
            T(0.445948490915965),  T(0.445948490915965)).finished();

    const Vector6R weights = (Vector6R{}
         << T(0.109951743655322),
            T(0.109951743655322),
            T(0.109951743655322),
            T(0.223381589678011),
            T(0.223381589678011),
            T(0.223381589678011)).finished();

public:

    template<class F>
    T integrate(const F& f) const
    {
        Vector6R values = Vector6R::Zero();

        for (int i = 0; i < 6; ++i) {
            auto row = interpolationPoints.row(i);
            values[i] = f(row[0], row[1]);
        }

        return T(0.5) * values.dot(weights);
    }
};